{
  "bugs": [
    {
      "name": "Trust identity format mismatch on sign",
      "description": "When signing a tool and adding the identity to trusted auditors, the sign command calls emailToProviderIdentity() without passing the OIDC issuer. This causes it to fall back to email domain matching. For emails with non-standard domains (e.g., @jointheleague.org), it stores just the email (e.g., 'keith.groves@jointheleague.org') instead of the provider-prefixed format (e.g., 'github:keith.groves@jointheleague.org'). However, during verification, the issuer IS available from the certificate and is passed to emailToProviderIdentity(), resulting in the correct 'github:email' format. This mismatch causes trust verification to fail.",
      "expected_behavior": "The sign command should extract the issuer from the Sigstore certificate and pass it to emailToProviderIdentity() so that the identity added to config matches what verification produces. Alternatively, verification should also check against the raw email format for backwards compatibility.",
      "status": "fixed",
      "location": "packages/cli/src/commands/sign/index.ts - promptAddToTrustList()",
      "workaround": "Manually edit ~/.enact/config.yaml to prefix the identity with the provider (e.g., 'github:email@domain.com')",
      "fix": "Modified promptAddToTrustList() to accept an issuer parameter and extract it from the Sigstore certificate bundle using extractCertificateFromBundle(). The issuer is now passed to emailToProviderIdentity() in both signRemoteTool() and signLocalTool()."
    },
    {
      "name": "Local sign before publish creates hash mismatch",
      "description": "When running 'enact sign ./path' before 'enact publish ./path', the attestation is created for the manifest content hash (e.g., sha256:5b312921...). However, 'enact publish' creates a bundle with a different hash (e.g., sha256:95e67e4a...). During verification, the attestation's subject hash doesn't match the published bundle hash, causing cryptographic verification to fail with 'Cryptographically verified: 0'.",
      "expected_behavior": "Either: (1) The sign command should compute the same bundle hash that publish will use, (2) Publish should automatically re-sign with the correct bundle hash, or (3) The workflow should enforce publish-then-sign order (as remote signing does correctly).",
      "status": "fixed",
      "location": "packages/cli/src/commands/sign/index.ts and packages/cli/src/commands/publish/index.ts",
      "workaround": "Use remote signing after publishing: 'enact publish ./path' then 'enact sign toolname@version'",
      "fix": "Added a warning in signLocalTool() that explains the hash mismatch issue and recommends the correct workflow (publish first, then sign remotely). Users are prompted to confirm if they want to continue with local signing anyway."
    },
    {
      "name": "enact get command does not parse @version syntax",
      "description": "The 'enact get' command uses '--ver <version>' option instead of parsing the '@version' suffix from the tool name. Running 'enact get enact/test/remote-sign-demo@0.1.1' treats the entire string as the tool name and returns 'Tool not found'. This is inconsistent with other commands like 'sign' and 'install' which do parse the '@version' syntax.",
      "expected_behavior": "The 'enact get' command should parse 'name@version' syntax for consistency with other commands. 'enact get tool@1.0.0' should be equivalent to 'enact get tool --ver 1.0.0'.",
      "status": "open",
      "location": "packages/cli/src/commands/get/index.ts",
      "workaround": "Use 'enact get toolname --ver 0.1.1' instead of 'enact get toolname@0.1.1'"
    },
    {
      "name": "Attestation bundle fetch endpoint returns NOT_FOUND",
      "description": "The getAttestationBundle() function in packages/api/src/attestations.ts calls '/tools/{name}/versions/{version}/trust/attestations/{auditor}' to fetch the full Sigstore bundle, but this endpoint returns 404 NOT_FOUND. The attestation metadata exists at '/tools/{name}/versions/{version}/attestations' but the bundle fetch endpoint doesn't work. This causes verifyAllAttestations() to fail for all attestations, resulting in '0 attestation(s)' during install even though the attestation was successfully submitted.",
      "expected_behavior": "The '/tools/{name}/versions/{version}/trust/attestations/{auditor}' endpoint should return the full Sigstore bundle for local verification, or the endpoint URL should be corrected to match the server implementation.",
      "status": "fixed",
      "location": "packages/server/supabase/functions/tools/index.ts",
      "workaround": "None - local verification is broken until endpoint is fixed",
      "investigation_notes": "Verified that: (1) Attestation metadata exists at /tools/.../attestations endpoint, (2) Bundle fetch endpoint at /tools/.../trust/attestations/{auditor} returns 404, (3) verifyAllAttestations() catches the error and returns empty array",
      "fix": "Added the /tools/{name}/versions/{version}/trust/attestations/{auditor} route and handleGetAttestationBundle() function to packages/server/supabase/functions/tools/index.ts. The route was only defined in attestations/index.ts but the client calls the tools function. REQUIRES DEPLOYMENT: Run 'supabase functions deploy tools' to deploy the fix to production."
    },
    {
      "name": "enact -v should show version",
      "description": "Running 'enact -v' or 'enact --version' should display the CLI version number, but it currently does not work as expected.",
      "expected_behavior": "The 'enact -v' and 'enact --version' commands should print the current version of the CLI (e.g., '0.1.0').",
      "status": "open",
      "location": "packages/cli/src/index.ts or main CLI entry point"
    },
    {
      "name": "enact get --verbose shows wrong latest version",
      "description": "Running 'enact get toolname --verbose' fetches the rawManifest for the 'latestVersion' but the latestVersion field returns an older version (e.g., 1.0.0) instead of the most recently published version (e.g., 1.0.1). This causes the rawManifest content to be missing or stale when using --verbose without specifying --ver.",
      "expected_behavior": "The latestVersion field should return the highest semver version, or the most recently published version. 'enact get toolname --verbose' should show the rawManifest for the actual latest version.",
      "status": "open",
      "location": "packages/server/supabase/functions/tools/index.ts - handleGetTool() or the tools table latest_version column update logic",
      "workaround": "Use 'enact get toolname --ver <version> --verbose' to specify the exact version"
    },
    {
      "name": "enact sign should prompt for version when signing remote tool without version",
      "description": "When running 'enact sign author/tool' without a version suffix, the parseRemoteToolRef() function returns null because there's no '@' symbol. This causes the code to fall through to signLocalTool() which treats the input as a local path and fails with 'No manifest found at: author/tool'. The user sees a confusing error message instead of being prompted to select a version.",
      "expected_behavior": "When a remote tool reference is provided without a version (e.g., 'enact sign enact/context7/docs'), the command should: (1) Detect this is a remote tool reference (contains '/' but no '@'), (2) Fetch available versions from the registry, (3) Prompt the user to select which version to sign, or (4) Default to the latest version if --latest flag is provided.",
      "status": "open",
      "location": "packages/cli/src/commands/sign/index.ts - parseRemoteToolRef() and signHandler()",
      "workaround": "Always specify the version explicitly: 'enact sign author/tool@1.0.0'"
    },
    {
      "name": "Sigstore signing fails with 'error creating signing certificate'",
      "description": "When running 'enact sign author/tool@version' for a remote tool, after confirming the sign prompt, the signing process fails with 'error creating signing certificate'. The OIDC flow completes (browser opens, user authenticates, token received), but Fulcio rejects the certificate request. This occurs during the attest() call in sigstore-js when trying to obtain a signing certificate from Fulcio. There's a postinstall patch (scripts/patch-sigstore.js) that fixes BoringSSL compatibility for EC key signing, but there may be additional issues with the certificate request itself.",
      "expected_behavior": "The signing flow should complete successfully: authenticate via OIDC, create attestation, obtain certificate from Fulcio, sign, log to Rekor, and submit to registry.",
      "status": "fixed",
      "location": "packages/trust/src/sigstore/signing.ts - signAttestation(), packages/trust/src/sigstore/oauth/",
      "fix": "The issue was caused by using a stale compiled binary that didn't have the sigstore patches properly applied. The fix is to ensure all packages are rebuilt in the correct order: bun run build:trust && bun run build:cli && node scripts/build-platform-binary.mjs. The sigstore patches in scripts/patch-sigstore.js need to be applied at postinstall time."
    },
    {
      "name": "Sign command offers to add identity that already exists in trust config",
      "description": "After signing a tool, the CLI prompts 'Would you like to add this identity to ~/.enact/config.yaml?' even if the identity already exists in the trusted auditors list. The user can say Yes and it will add a duplicate entry or not properly detect the existing entry.",
      "expected_behavior": "The sign command should check if the identity (in any format - email, provider:email, etc.) already exists in the trusted auditors list before offering to add it. If it exists, it should say 'This identity is already in your trusted auditors list' and skip the prompt.",
      "status": "open",
      "location": "packages/cli/src/commands/sign/index.ts - promptAddToTrustList()",
      "workaround": "Decline the prompt if you know the identity is already trusted"
    },
    {
      "name": "Optional parameters in command templates require explicit values",
      "description": "When a tool's command template uses positional parameter substitution (e.g., 'python main.py ${library_id} ${mode} ${topic} ${page}'), optional parameters marked in the inputSchema are not truly optional. Running 'enact run tool --args {\"library_id\": \"/vercel/next.js\"}' fails with 'Missing required parameter: topic' even though topic is not in the schema's required array. The command template expects all positional arguments to be present.",
      "expected_behavior": "Optional parameters should use their default values when not provided. Enact should either: (1) Pass empty strings or default values for missing optional parameters in positional substitution, (2) Support JSON stdin as an alternative to positional args, or (3) Clearly document that command templates with positional args require all params.",
      "status": "open",
      "location": "packages/cli/src/commands/run/ - parameter substitution logic",
      "workaround": "Provide all parameters including empty strings for optional ones: --args '{\"library_id\": \"/vercel/next.js\", \"mode\": \"code\", \"topic\": \"\", \"page\": 1}'",
      "investigation_notes": "See feedback.md and feedback2.md for detailed UX analysis. The schema marks topic/mode/page as optional with defaults, but the command template requires all 4 positional args. Error message is misleading since it says 'required' for an optional param."
    },
    {
      "name": "enact get does not show input schema details",
      "description": "Running 'enact get toolname' or 'enact get toolname --verbose' does not display the tool's input schema (parameters, types, required vs optional, defaults). Users cannot discover what parameters a tool accepts without manually reading the tool's enact.md source file.",
      "expected_behavior": "The 'enact get' command should have a --schema or --help flag that displays the full input schema including: parameter names, types, required/optional status, default values, descriptions, and enum options.",
      "status": "open",
      "location": "packages/cli/src/commands/get/index.ts",
      "workaround": "Manually read the tool's enact.md file or repository documentation"
    }
  ]
}
